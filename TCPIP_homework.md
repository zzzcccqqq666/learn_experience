## 11章

1.什么是进程间通信？分别从概念上和内存的角度进行说明。

- 进程间通信意味着两个不同进程间可以交换数据
- 只要有两个进程可以同时访问的内存空间，就可以通过此空间交换数据

2.进程间通信需要特殊的IPC机制，这是由操作系统提供的。进程间通信时为何需要操作系统的帮助？
进程间有完全独立的内存结构。就连通过fork函数创建的子进程也不会与父进程共享内存空间。

IPC(Inter-Process Communication）

3.管道是经典的IPC技法。关于管道，请回答如下问题。
a.管道是进程间交换数据的路径。如何创建此路径？由谁创建？

- 使用`int pipe(int fileds[2])`创建，由操作系统创建

b.为了完成进程间通信，2个进程需同时链接管道。那2个进程如何连接到同一管道

- 父进程创建管道时，同时获取对应于出入口的文件描述符。将入口或出口中的一个文件描述符传递给子进程，则2个进程连接到同一管道。

c.管道运行进行2个进程间的双向通信。双向通信需要注意哪些内容？

- 数据进入管道后成为无主数据。也就是通过read函数先读取数据的进程将得到数据，即使该进程将数据传到了管道。
- 只用1个管道进行双向通信需要预测并控制运行流程，这在每种系统中都不同，可以视为不可能完成的任务。
- 双向通信需要创建2个管道，各自负责不同的数据流动。

3.编写示例复习IPC技法，使2个进程相互交换3次字符串。当然，这2个进程应具有父子关系，各位可指定任意字符串。

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define BUF_SIZE 30

int main()
{
    char msg1[] = "this is str1";
    char msg2[] = "this is str2";
    char msg3[] = "this is str3";
    char buf[BUF_SIZE];

    int fds1[2], fds2[2];
    pipe(fds1);
    pipe(fds2);
    pid_t pid = fork();
    if (pid == 0)
    {
        write(fds1[1], msg1, sizeof(msg1));
        read(fds2[0], buf, BUF_SIZE);
        printf("child proc: %s\n", buf);
        write(fds1[1], msg3, sizeof(msg3));
    }
    else
    {
        read(fds1[0], buf, BUF_SIZE);
        printf("parent proc: %s\n", buf);
        write(fds2[1], msg2, sizeof(msg2));
        read(fds1[0], buf, BUF_SIZE);
        printf("parent proc: %s\n", buf);
    }
    return 0;
}

```

## 12章

**1.请解释复用技术的通用含义，并说明何为I/O复用。**

- 在1个通信频道中传递多个数据（信号）的技术。
- 将多个文件描述符集中到一起统一监视，如果某个文件描述符发生了变化，则对文件描述符做相应的处理

**2.多进程并发服务器的缺点有哪些？如何在I/O复用服务器端中弥补？**

- 多进程并发服务器，只要有客户端连接请求就会创建新进程。创建进程时需要大量的运算和内存空间。由于每个进程都具有独立的内存空间，所以相互间的数据交换也要求采用相对复杂的方法(IPC)。
- I/O复用，无论连接多少个客户端，提供服务的进程只有1个。

**3.复用服务器端需要select函数。下列关于select函数使用方法的描述错误的是？**
a.调用select函数前需要集中I/O监视对象的文件描述符。

- 正确，要将监视的文件描述符注册到fd_set变量中

b.若已通过select函数注册为监视对象，则后续调用select函数时无需重复注册。

- 错误，在调用select函数后，除了发生变化的文件描述符，其他已注册的文件描述符在fd_set中的位由1变为0

c.复用服务器端同一时间只能服务于1个客户端，因此，需要服务的客户端接入服务器端后只能等待。

- 错误，服务器端可以同时服务多个客户端。select可以监视多个的文件描述符，也就是监视多个套接字，在返回后统一处理。需要服务的客户端只要等到上一个文件描述符的事件处理完后就可以接受服务。

d.与多进程服务器端不同，基于select的复用服务器端只需要1个进程。因此可以减少因创建进程产生的服务器端产生的负担。

- 正确，select函数可以同时监视多个文件描述符，也就是监视多个套接字。连接多个客户端，只需监视多个对应的文件描述符即可，不需要新建进程。

**4.select函数的观察对象中应包含服务端套接字（监听套接字），那么应将其包含到哪一类监听对象集合？请说明原因。**

- 是否存在套接字接收数据
- 客户端连接请求本身也是从网络中接收到的一种数据，而接收客户端连接请求的任务是由服务器端套接字完成的

**5.select函数中使用的fd_set结构体在Windows和Linux中具有不同声明。请说明区别，同时解释存在区别的必然性。**

## 13章

**1.下列关于MSG_OOB可选项的说法错误的是？**
a.MSG_OOB指传输Out-of-band数据，是通过其他路径高速传输数据。

- TCP不另外提供单独的通信路径高速传输数据，只是利用TCP的紧急模式进行传输。

b.MSG_OOB指通过其他路径高速传输数据，因此，TCP中设置该选项的数据先到达对方主机。

- TCP不另外提供单独的通信路径高速传输数据，只利用TCP紧急模式进行传输。而且TCP“保持传输顺序”的传输特性依然成立。

c.设置MSG_OOB使数据先到达对方主机后，以普通数据的形式和顺序读取。也就是说，只是提高了传输速度，接收方无法识别这一点。

- 设置MSG_OOB后，使用TCP紧急模式进行传输数据，TCP保持传输顺序的传输特性依然成立。不会加快数据传输速度。紧急消息的意义在于督促消息处理，而非紧急传输形式受限的消息。

d.MSG\_OOB无法脱离TCP的默认数据传输方式。即使设置了MSG\_OOB，也会保持原有的传输顺序。该选项只用于要求接收方紧急处理。

- 正确，MSG_OOB可选项利用TCP的紧急模式进行传输数据，紧急消息的真正意义在于督促消息处理，而非紧急传输形式受限的消息。

**2.利用readv&writev函数收发数据有何优点？分别从调用次数和I/O缓冲的角度给出说明**

- 需要传输的数据分别位于不同缓冲（数组）时，如果调用write函数，就需要调用多次；如果使用writev，就可以通过1次writev函数调用将数据写入到输出缓冲。同样，需要将输入缓冲中的数据读入不同位置时，如果调用read函数就需要调用多次；而使用readv函数，则调用1次就可以满足要求。
- 假设为了提高效率而在服务器端明确阻止了Nagle算法，数据到达输出缓冲就发送。如果数据在多个不同的缓冲，如果此时使用write函数则需要调用多次。可能传递多个数据包。反之，若使用writev函数将所有数据一次性写入输出缓冲，则很有可能仅通过1个数据包传递数据。这样可以减少网络中数据包的个数。

**3.通过recv函数验证输入缓冲是否存在数据时（确认后立即返回时），如何设置recv函数最后一个参数中的可选项？分别说明各可选项的含义**

- MSG\_PEEK|MSG\_DONTWAIT
- MSG_PEEK：验证输入缓冲中是否存在接收的数据
- MSG_DONTWAIT：调用I/O函数时不阻塞，用于使用非阻塞(Non-blocking)I/O

**4.可在Linux平台通过注册事件处理函数接收MSG_OOB数据。那Windows中如何接收？请说明接收方法**



## 14章

### 1.TTL的含义是什么？请从路由器的角度说明较大的TTL值与较小的TTL值之间的区别及问题
- TTL是Time to Live的简写，是一个决定数据包传递距离的整数。在传递多播数据包的过程中，每经过1个路由器就减1.当TTL变为0时，该数据不无法再被传递，只能销毁。
- TTL的值设置过大将影响网络流量；设置过小会无法传递到目标

### 多播与广播的异同点是什么？请从数据通信的角度进行说明
- 多播和广播都可以一次性向多个主机发送数据
- 多播和广播传输数据的范围不同。多播即使在跨越不同网络的情况下，只要加入多播组就能接收数据。相反，广播只能向同一网络中的主机传输数据。

### 下列关于多播秒数错误的是？
#### a.多播是用来向加入多播组的所有主机传输数据的协议
正确
#### b.主机连接到同一网络才能加入多播组，也就是说，多播组无法跨越多个网络
错误，即使在跨越不同网络的情况下，只要加入多播组就能接收数据
#### c.能够加入多播组的主机数并无限制，但只能有1个主机（Sender）向该组发送数据
错误，加入特定组即可接收发往该多播组的数据，并无数量限制。只要设置好TTL和多播地址，任何主机都可以向改组发送数据。
#### d.多播时使用的套接字是UDP套接字，因为多播是基于UDP进行数据通信的
正确

### 多播也对网络流量有利，请比较TCP数据交换方式解释其原因
- 多播向网络传递1个多播数据包时，路由器将复制该数据包并传递到多个主机，因此，不会向同一区域（网络）发送多个相同的数据包。
- 若通过TCP向1000个主机发送文件，则共需要传递1000次，即便将1000台主机合为一个网络，使99%的传输路径相同的情况下也是如此。但此时若使用多播方式传输文件，则只需发送1次。这时由1000台主机构成的网络中的路由器负责复制文件并传递到主机。

### 多播方式的数据通信需要MBone虚拟网络。换言之，MBone是用于多播的网络，但它是虚拟网络。请解释此处的“虚拟网络”
- 通过网络中的特殊协议工作的软件概念上的网络。
- 也就是说，MBone并非可以触及的物理网络。它是以物理网络为基础，通过软件方法实现的多播通信必备虚拟网络。


## 15章

### 1.请说明标准I/O函数的2个优点。它为何拥有这2个优点？
- 标准I/O函数具有良好的移植性。所有的标准函数具有良好的移植性，这些函数都是按照ANSI C标准定义的。
- 标准I/O函数可以利用缓冲提高性能。使用标准I/O函数时会得到额外的缓冲支持。在传输数据时，使用缓冲可以减少传输的数据量，同时减少数据向输出缓冲移动的次数。

### 利用标准I/O函数传输数据时，下面的想法是错误的：
“调用fputs函数传输数据时，调用后应立即开始发送！”
为何说上述想法是错误的？为了达到这种效果应添加哪些处理过程？
- fputs是标准I/O函数，使用标准I/O函数传输数据时，会得到额外的缓冲支持。使用fputs传输数据时，首先将数据传递到标准I/O的缓冲，待缓冲满了后再将数据移动到套接字输出缓冲，最后将字符串发送到对方主机。
- 调用完fputs函数后，调用fflush函数，强迫将标准I/O函数缓冲区内的数据移动到套接字输出缓冲中，立即开始发送数据。


## 16章

### 1.下列关于FILE结构体指针和文件描述符的说法错误的是？
#### a. 与FILE结构体指针相同，文件描述符也分为输入描述符和输出描述符。
错误，文件描述符本身不会根据输入和输出进行区分。
#### b. 复制文件描述符时将生成相同值的描述符，可以通过这两个描述符进行I/O。
错误，复制文件描述符的含义是，为了访问同一文件或套接字，创建另一个文件描述符。值是不同的。
#### c. 可以利用创建套接字时返回的文件描述符进行I/O，也可以不通过文件描述符，直接通过FILE结构体指针完成。
错误，FILE结构体指针是基于文件描述符创建的。
#### d. 可以从文件描述符生成FILE结构体指针，而且可以利用这种FILE结构体指针进行套接字I/O。
正确，调用fdopen()基于文件描述符创建FILE结构体指针，调用标准函数fputs(),fgets()基于FILE结构体指针进行套接字I/O。
#### e.若文件描述符为读模式，则基于该描述符生成的FILE结构体指针同样是读模式；若文件描述符为写模式，则基于该描述符生成的FILE结构体指针同样是写模式。
错误，文件描述符不区分读模式和写模式。FILE结构体指针的模式由调用fdopen()时的参数决定。

### 2.EOF的发送相关描述错误的是？
#### a.中止文件描述符时发送EOF.
错误，若有多个文件描述符指向一个套接字，中止其中一个文件描述符不会发送EOF。
#### b.即使未完全中止文件描述符，关闭输出流时也会发送EOF.
正确
#### c.如果复制文件描述符，则包括复制文件描述符在内，所有文件描述符都中止时才会发送EOF.
正确
#### d.即使复制文件描述符，也可以通过调用shutdown函数进入半关闭状态并发送EOF。
正确


## 17章

### 1.利用select函数实现服务器端时，代码层面存在的2个缺点是？
- 调用select函数后常见的针对所有文件描述符的循环语句
- 每次调用select函数时都需要向该函数传递监视对象信息

### 2.无论是select方式还是epoll方式，都需要将监视对象文件描述符信息通过函数调用传递给操作系统。请解释传递该信息的原因。
监视文件描述符，就是监视套接字。而套接字是操作系统管理的资源，因此需要将文件描述符传递给操作系统。

### 3.select方式和epoll方式的最大差异在于监视对象文件描述符传递给操作系统的方式。说明具体的差异，并解释为何存在这种差异。
- select方式是在每次调用select函数时向操作系统传递监视对象信息；epoll方式是仅向操作系统传递1次监视对象，监视范围或内容发生变化时只通知发送变化的事项。
- select函数是通过观察作为监视对象的fd_set变量的变化，找出发生变化的文件描述符。每次调用完select函数后，作为监视对象的fd_set变量会发生变化，所以调用select函数前应复制并保存原有信息，并在每次调用select函数时传递新的监视对象信息；epoll方式下由操作系统负责保存监视对象的文件描述符，因此仅传递1次监视对象。

### 4.虽然epoll是select的改进方案，但select也有自己的优点。在何种情况下使用select方式更合理？
- 服务端接入者少
- 程序应具有兼容性

### 5.epoll以条件触发或边缘触发方式工作。二者有何区别？从输入缓冲的角度说明这2种方式通知事件的时间点差异。
条件触发和边缘触发的区别在于发生事件的时间点。条件触发方式中，只要输入缓冲有数据就会一直通知该事件；边缘触发中输入缓冲收到数据时仅注册1次该事件。即使输入缓冲中还留有数据，也不会再进行注册。

### 6.采用边缘触发时可以分离数据的接收和处理时间点。说明其原因及优点
- 边缘触发中输入缓冲收到数据时仅注册一次该事件。
- 即使输入缓冲收到数据（注册相应事件），服务器端也能决定读取和处理这些数据端时间点，这样就给服务端端的实现带来巨大的灵活性。 



## 18章

### 1.单CPU系统中如何同时执行多个进程？请解释该过程中发生的上下文切换。
- 系统将CPU时间分成多个微小的块后分配给了多个进程。
- 运行程序前需要将相应进程信息读入内存，如果运行进程A后需要紧接着运行进程B，就应该将进程A相关信息移出内存，并读入进程B相关信息。这就是上下文切换。

### 2.为何线程的上下文切换速度更快？线程间数据交换为何不需要类似IPC的特别技术？
- 线程上下文切换时不需要切换数据区和堆。
- 同一进程内的线程可以利用数据区和堆交换数据。

### 3.请从执行流角度说明进程和线程的区别。
- 进程：在操作系统构成单独执行流的单位。
- 线程：在进程构成单独执行流的单位。
- 进程在操作系统内部生成多个执行流，线程在同一进程内部创建多条执行流。

### 下列关于临界区的说法错误的是？
#### a.临界区是多个线程同时访问时发生问题的区域。
错误，临界区是函数内同时运行多个线程时引起问题的多条语句构成的代码块。
### b.线程安全的函数中不存在临界区，即便多个线程同时调用也不会发生问题。
错误，线程安全函数中可能存在临界区。在线程安全函数中，同时被多个线程调用时可通过一些措施避免问题。
#### c.1个临界区只能由1个代码块，而非多个代码块构成。换言之，线程A执行的代码块A和线程B执行的代码块B之间不会构成临界区。
错误，如果代码块A和代码块B访问同一内存空间，在由不同线程同时执行时，也有可能构成临界区。
#### d.临界区由访问全局变量的代码构成。其他变量不会发生问题。
错误，访问堆中变量的代码也有可能构成临界区。

### 5.下列关于线程同步的描述错误的是？
#### a.线程同步就是限制访问临界区。
错误，限制访问临界区是同时访问同一内存空间发生的情况。线程同步还有需要指定访问同一内存空间的线程执行顺序的情况。
#### b.线程同步也具有控制线程执行顺序的含义。
正确
#### c.互斥量和信号量是典型的同步技术。
正确
#### d.线程同步是代替进程IPC的技术。
错误，进程IPC是进程间通信技术，线程同步用于解决线程访问顺序引发的问题。

### 6.请说明完全销毁Linux线程的2种方法。
- 调用pthread_join函数：等待线程终止，引导线程销毁。线程终止前，调用该函数的线程将进入阻塞状态。
- 调用pthread_detach函数：不会引起线程终止或进入阻塞状态，引导销毁线程创建的内存空间。

### 7.请利用多线程技术实现回声服务器端，但要让所有线程共享保存客户端消息的内存空间（char数组）。这么做只是为了应用本章的同步技术，其实不符合常理。
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <pthread.h>
#include <unistd.h>
#include <arpa/inet.h>

#define BUF_SIZE 100
#define CLNT_SIZE 256

void *handle_clnt(void *arg);
void *send_msg(char *msg, int len);
void error_handling(const char *msg);

pthread_mutex_t mutex;
char buf[BUF_SIZE];

int main(int argc, char *argv[])
{
    int serv_sock, clnt_sock;
    struct sockaddr_in serv_addr, clnt_addr;
    socklen_t clnt_addr_sz;

    if (argc != 2)
    {
        printf("Usage: %s <port>\n", argv[0]);
        exit(1);
    }

    serv_sock = socket(PF_INET, SOCK_STREAM, 0);
    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    serv_addr.sin_port = htons(atoi(argv[1]));

    if (bind(serv_sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) == -1)
        error_handling("bind() error");

    if (listen(serv_sock, 5) == -1)
        error_handling("listen() error");

    pthread_t tid;
    pthread_mutex_init(&mutex, NULL);
    while (1)
    {
        clnt_addr_sz = sizeof(&clnt_addr);
        clnt_sock = accept(serv_sock, (struct sockaddr *)&clnt_addr, &clnt_addr_sz);

        pthread_create(&tid, NULL, handle_clnt, (void *)&clnt_sock);
        pthread_detach(tid);
        printf("connected client IP: %s\n", inet_ntoa(clnt_addr.sin_addr));
    }
    close(serv_sock);
    pthread_mutex_destroy(&mutex);
    return 0;
}

void *handle_clnt(void *arg)
{
    int clnt_sock = *(int *)arg;
    int str_len = 0;

    while (1)
    {
        pthread_mutex_lock(&mutex);
        str_len = read(clnt_sock, buf, BUF_SIZE);
        if (str_len <= 0)
        {
            pthread_mutex_unlock(&mutex);
            break;
        }
        write(clnt_sock, buf, str_len);
        pthread_mutex_unlock(&mutex);
    }

    close(clnt_sock);
    return NULL;
}


void error_handling(const char *msg)
{
    fputs(msg, stderr);
    fputc('\n', stderr);
    exit(1);
}

```

### 8.上一题要求所有线程共享保存回声消息的内存空间，如果采用这种方式，无论是否同步都会产生问题。请说明每种情况各产生哪些问题。
- 同步：使用互斥量同步后，如果同时连接多个客户端，创建多个线程，因为同步的关系，同一时刻只有一个线程能拿到互斥量，其他线程会被阻塞。只有一个客户端处理完了，释放掉互斥量，下一个客户端的请求才能被处理。
- 不同步，同时连接多个客户端，可能导致一个客户端的数据接收后还没得及发送，保存回声消息的内存空间就被另一个客户端的数据覆盖了，导致发送了错误的数据。


## 24章

### 1.下列关于Web服务器端和Web浏览器的说法错误的是？
#### a.Web浏览器并不是通过自身创建的套接字连接服务器端的客户端。
错误，浏览器连接到任意Web服务器端时，浏览器内部也会创建套接字。
#### b.Web服务器通过TCP套接字提供服务，因为它将保持较长的客户端连接并交换数据。
错误，HTTP是无状态的Stateless协议，Web服务器端响应客户端请求后立即断开连接。
#### c.超文本和普通文本的最大区别是其具有可跳转的特性。
正确，Hypertext（超文本）是可以根据客户端请求而跳转的结构化信息。
#### d.Web服务器端可视为向浏览器提供请求文件的文件传输服务器端。
正确，Web服务器端是以HTTP协议为基础传输超文本的服务器端。浏览器向Web服务器端请求超文本文件，Web服务器端响应请求，将该超文本文件传输给浏览器。
#### e.除Web浏览器外，其他客户端都无法访问Web服务器端。
错误，任意客户端，只要正确的和Web服务器端建立连接，都可以访问Web服务器端。只不过浏览器多了一项功能，它将服务器端传输的HTML格式的超文本解析为可读性较强的视图。

### 2.下列关于HTTP协议的描述错误的是？
#### a.HTTP协议是无状态的Stateless协议，不仅可以通过TCP实现，还可通过UDP实现。
错误，HTTP协议是基于TCP/IP实现的协议。
#### b.HTTP协议是无状态的Stateless协议，因为其在1次请求和响应过程完成后立即断开连接。因此，如果同一服务器端和客户端需要3次连接请求及相应，则意味着要经过3次套接字创建过程。
错误，要经历3次建立连接的过程，套接字可以重复使用。
#### c.服务器端向客户端传递的状态码中含有请求处理结果信息。
正确，状态码是表示客户端请求的执行结果的数字。
#### d.HTTP协议是基于因特网的协议，因此，为了同时向大量客户端提供服务，HTTP被设计为Stateless协议。
错误，HTTP协议是基于TCP/IP的协议。

### 3.IOCP和epoll是可以保证高性能的典型服务端模型，但如果在基于HTTP协议的Web服务器端使用这些模型，则无法保证一定能得到高性能。请说明原因。
客户端和服务器端交换1次数据后立即断开连接，没有足够时间发挥IOCP或epoll的优势。在服务器端和客户端保持较长连接的前提下频繁发送大小不一的消息时（最典型的就是网游服务器端），才能真正发挥出这2种模型的优势。