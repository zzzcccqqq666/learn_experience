## 11章

1.什么是进程间通信？分别从概念上和内存的角度进行说明。

- 进程间通信意味着两个不同进程间可以交换数据
- 只要有两个进程可以同时访问的内存空间，就可以通过此空间交换数据

2.进程间通信需要特殊的IPC机制，这是由操作系统提供的。进程间通信时为何需要操作系统的帮助？
进程间有完全独立的内存结构。就连通过fork函数创建的子进程也不会与父进程共享内存空间。

IPC(Inter-Process Communication）

3.管道是经典的IPC技法。关于管道，请回答如下问题。
a.管道是进程间交换数据的路径。如何创建此路径？由谁创建？

- 使用`int pipe(int fileds[2])`创建，由操作系统创建

b.为了完成进程间通信，2个进程需同时链接管道。那2个进程如何连接到同一管道

- 父进程创建管道时，同时获取对应于出入口的文件描述符。将入口或出口中的一个文件描述符传递给子进程，则2个进程连接到同一管道。

c.管道运行进行2个进程间的双向通信。双向通信需要注意哪些内容？

- 数据进入管道后成为无主数据。也就是通过read函数先读取数据的进程将得到数据，即使该进程将数据传到了管道。
- 只用1个管道进行双向通信需要预测并控制运行流程，这在每种系统中都不同，可以视为不可能完成的任务。
- 双向通信需要创建2个管道，各自负责不同的数据流动。

3.编写示例复习IPC技法，使2个进程相互交换3次字符串。当然，这2个进程应具有父子关系，各位可指定任意字符串。

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define BUF_SIZE 30

int main()
{
    char msg1[] = "this is str1";
    char msg2[] = "this is str2";
    char msg3[] = "this is str3";
    char buf[BUF_SIZE];

    int fds1[2], fds2[2];
    pipe(fds1);
    pipe(fds2);
    pid_t pid = fork();
    if (pid == 0)
    {
        write(fds1[1], msg1, sizeof(msg1));
        read(fds2[0], buf, BUF_SIZE);
        printf("child proc: %s\n", buf);
        write(fds1[1], msg3, sizeof(msg3));
    }
    else
    {
        read(fds1[0], buf, BUF_SIZE);
        printf("parent proc: %s\n", buf);
        write(fds2[1], msg2, sizeof(msg2));
        read(fds1[0], buf, BUF_SIZE);
        printf("parent proc: %s\n", buf);
    }
    return 0;
}

```

## 12章

**1.请解释复用技术的通用含义，并说明何为I/O复用。**

- 在1个通信频道中传递多个数据（信号）的技术。
- 将多个文件描述符集中到一起统一监视，如果某个文件描述符发生了变化，则对文件描述符做相应的处理

**2.多进程并发服务器的缺点有哪些？如何在I/O复用服务器端中弥补？**

- 多进程并发服务器，只要有客户端连接请求就会创建新进程。创建进程时需要大量的运算和内存空间。由于每个进程都具有独立的内存空间，所以相互间的数据交换也要求采用相对复杂的方法(IPC)。
- I/O复用，无论连接多少个客户端，提供服务的进程只有1个。

**3.复用服务器端需要select函数。下列关于select函数使用方法的描述错误的是？**
a.调用select函数前需要集中I/O监视对象的文件描述符。

- 正确，要将监视的文件描述符注册到fd_set变量中

b.若已通过select函数注册为监视对象，则后续调用select函数时无需重复注册。

- 错误，在调用select函数后，除了发生变化的文件描述符，其他已注册的文件描述符在fd_set中的位由1变为0

c.复用服务器端同一时间只能服务于1个客户端，因此，需要服务的客户端接入服务器端后只能等待。

- 错误，服务器端可以同时服务多个客户端。select可以监视多个的文件描述符，也就是监视多个套接字，在返回后统一处理。需要服务的客户端只要等到上一个文件描述符的事件处理完后就可以接受服务。

d.与多进程服务器端不同，基于select的复用服务器端只需要1个进程。因此可以减少因创建进程产生的服务器端产生的负担。

- 正确，select函数可以同时监视多个文件描述符，也就是监视多个套接字。连接多个客户端，只需监视多个对应的文件描述符即可，不需要新建进程。

**4.select函数的观察对象中应包含服务端套接字（监听套接字），那么应将其包含到哪一类监听对象集合？请说明原因。**

- 是否存在套接字接收数据
- 客户端连接请求本身也是从网络中接收到的一种数据，而接收客户端连接请求的任务是由服务器端套接字完成的

**5.select函数中使用的fd_set结构体在Windows和Linux中具有不同声明。请说明区别，同时解释存在区别的必然性。**

## 13章

**1.下列关于MSG_OOB可选项的说法错误的是？**
a.MSG_OOB指传输Out-of-band数据，是通过其他路径高速传输数据。

- TCP不另外提供单独的通信路径高速传输数据，只是利用TCP的紧急模式进行传输。

b.MSG_OOB指通过其他路径高速传输数据，因此，TCP中设置该选项的数据先到达对方主机。

- TCP不另外提供单独的通信路径高速传输数据，只利用TCP紧急模式进行传输。而且TCP“保持传输顺序”的传输特性依然成立。

c.设置MSG_OOB使数据先到达对方主机后，以普通数据的形式和顺序读取。也就是说，只是提高了传输速度，接收方无法识别这一点。

- 设置MSG_OOB后，使用TCP紧急模式进行传输数据，TCP保持传输顺序的传输特性依然成立。不会加快数据传输速度。紧急消息的意义在于督促消息处理，而非紧急传输形式受限的消息。

d.MSG\_OOB无法脱离TCP的默认数据传输方式。即使设置了MSG\_OOB，也会保持原有的传输顺序。该选项只用于要求接收方紧急处理。

- 正确，MSG_OOB可选项利用TCP的紧急模式进行传输数据，紧急消息的真正意义在于督促消息处理，而非紧急传输形式受限的消息。

**2.利用readv&writev函数收发数据有何优点？分别从调用次数和I/O缓冲的角度给出说明**

- 需要传输的数据分别位于不同缓冲（数组）时，如果调用write函数，就需要调用多次；如果使用writev，就可以通过1次writev函数调用将数据写入到输出缓冲。同样，需要将输入缓冲中的数据读入不同位置时，如果调用read函数就需要调用多次；而使用readv函数，则调用1次就可以满足要求。
- 假设为了提高效率而在服务器端明确阻止了Nagle算法，数据到达输出缓冲就发送。如果数据在多个不同的缓冲，如果此时使用write函数则需要调用多次。可能传递多个数据包。反之，若使用writev函数将所有数据一次性写入输出缓冲，则很有可能仅通过1个数据包传递数据。这样可以减少网络中数据包的个数。

**3.通过recv函数验证输入缓冲是否存在数据时（确认后立即返回时），如何设置recv函数最后一个参数中的可选项？分别说明各可选项的含义**

- MSG\_PEEK|MSG\_DONTWAIT
- MSG_PEEK：验证输入缓冲中是否存在接收的数据
- MSG_DONTWAIT：调用I/O函数时不阻塞，用于使用非阻塞(Non-blocking)I/O

**4.可在Linux平台通过注册事件处理函数接收MSG_OOB数据。那Windows中如何接收？请说明接收方法**



## 14章
### 1.TTL的含义是什么？请从路由器的角度说明较大的TTL值与较小的TTL值之间的区别及问题
- TTL是Time to Live的简写，是一个决定数据包传递距离的整数。在传递多播数据包的过程中，每经过1个路由器就减1.当TTL变为0时，该数据不无法再被传递，只能销毁。
- TTL的值设置过大将影响网络流量；设置过小会无法传递到目标

### 多播与广播的异同点是什么？请从数据通信的角度进行说明
- 多播和广播都可以一次性向多个主机发送数据
- 多播和广播传输数据的范围不同。多播即使在跨越不同网络的情况下，只要加入多播组就能接收数据。相反，广播只能向同一网络中的主机传输数据。

### 下列关于多播秒数错误的是？
#### a.多播是用来向加入多播组的所有主机传输数据的协议
正确
#### b.主机连接到同一网络才能加入多播组，也就是说，多播组无法跨越多个网络
错误，即使在跨越不同网络的情况下，只要加入多播组就能接收数据
#### c.能够加入多播组的主机数并无限制，但只能有1个主机（Sender）向该组发送数据
错误，加入特定组即可接收发往该多播组的数据，并无数量限制。只要设置好TTL和多播地址，任何主机都可以向改组发送数据。
#### d.多播时使用的套接字是UDP套接字，因为多播是基于UDP进行数据通信的
正确

### 多播也对网络流量有利，请比较TCP数据交换方式解释其原因
- 多播向网络传递1个多播数据包时，路由器将复制该数据包并传递到多个主机，因此，不会向同一区域（网络）发送多个相同的数据包。
- 若通过TCP向1000个主机发送文件，则共需要传递1000次，即便将1000台主机合为一个网络，使99%的传输路径相同的情况下也是如此。但此时若使用多播方式传输文件，则只需发送1次。这时由1000台主机构成的网络中的路由器负责复制文件并传递到主机。

### 多播方式的数据通信需要MBone虚拟网络。换言之，MBone是用于多播的网络，但它是虚拟网络。请解释此处的“虚拟网络”
- 通过网络中的特殊协议工作的软件概念上的网络。
- 也就是说，MBone并非可以触及的物理网络。它是以物理网络为基础，通过软件方法实现的多播通信必备虚拟网络。