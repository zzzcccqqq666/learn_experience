## 11章

1.什么是进程间通信？分别从概念上和内存的角度进行说明。

- 进程间通信意味着两个不同进程间可以交换数据
- 只要有两个进程可以同时访问的内存空间，就可以通过此空间交换数据

2.进程间通信需要特殊的IPC机制，这是由操作系统提供的。进程间通信时为何需要操作系统的帮助？
进程间有完全独立的内存结构。就连通过fork函数创建的子进程也不会与父进程共享内存空间。

IPC(Inter-Process Communication）

3.管道是经典的IPC技法。关于管道，请回答如下问题。
a.管道是进程间交换数据的路径。如何创建此路径？由谁创建？

- 使用`int pipe(int fileds[2])`创建，由操作系统创建

b.为了完成进程间通信，2个进程需同时链接管道。那2个进程如何连接到同一管道

- 父进程创建管道时，同时获取对应于出入口的文件描述符。将入口或出口中的一个文件描述符传递给子进程，则2个进程连接到同一管道。

c.管道运行进行2个进程间的双向通信。双向通信需要注意哪些内容？

- 数据进入管道后成为无主数据。也就是通过read函数先读取数据的进程将得到数据，即使该进程将数据传到了管道。
- 只用1个管道进行双向通信需要预测并控制运行流程，这在每种系统中都不同，可以视为不可能完成的任务。
- 双向通信需要创建2个管道，各自负责不同的数据流动。

3.编写示例复习IPC技法，使2个进程相互交换3次字符串。当然，这2个进程应具有父子关系，各位可指定任意字符串。

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define BUF_SIZE 30

int main()
{
    char msg1[] = "this is str1";
    char msg2[] = "this is str2";
    char msg3[] = "this is str3";
    char buf[BUF_SIZE];

    int fds1[2], fds2[2];
    pipe(fds1);
    pipe(fds2);
    pid_t pid = fork();
    if (pid == 0)
    {
        write(fds1[1], msg1, sizeof(msg1));
        read(fds2[0], buf, BUF_SIZE);
        printf("child proc: %s\n", buf);
        write(fds1[1], msg3, sizeof(msg3));
    }
    else
    {
        read(fds1[0], buf, BUF_SIZE);
        printf("parent proc: %s\n", buf);
        write(fds2[1], msg2, sizeof(msg2));
        read(fds1[0], buf, BUF_SIZE);
        printf("parent proc: %s\n", buf);
    }
    return 0;
}

```

## 12章

**1.请解释复用技术的通用含义，并说明何为I/O复用。**

- 在1个通信频道中传递多个数据（信号）的技术。
- 将多个文件描述符集中到一起统一监视，如果某个文件描述符发生了变化，则对文件描述符做相应的处理

**2.多进程并发服务器的缺点有哪些？如何在I/O复用服务器端中弥补？**

- 多进程并发服务器，只要有客户端连接请求就会创建新进程。创建进程时需要大量的运算和内存空间。由于每个进程都具有独立的内存空间，所以相互间的数据交换也要求采用相对复杂的方法(IPC)。
- I/O复用，无论连接多少个客户端，提供服务的进程只有1个。

**3.复用服务器端需要select函数。下列关于select函数使用方法的描述错误的是？**
a.调用select函数前需要集中I/O监视对象的文件描述符。

- 正确，要将监视的文件描述符注册到fd_set变量中

b.若已通过select函数注册为监视对象，则后续调用select函数时无需重复注册。

- 错误，在调用select函数后，除了发生变化的文件描述符，其他已注册的文件描述符在fd_set中的位由1变为0

c.复用服务器端同一时间只能服务于1个客户端，因此，需要服务的客户端接入服务器端后只能等待。

- 错误，服务器端可以同时服务多个客户端。select可以监视多个的文件描述符，也就是监视多个套接字，在返回后统一处理。需要服务的客户端只要等到上一个文件描述符的事件处理完后就可以接受服务。

d.与多进程服务器端不同，基于select的复用服务器端只需要1个进程。因此可以减少因创建进程产生的服务器端产生的负担。

- 正确，select函数可以同时监视多个文件描述符，也就是监视多个套接字。连接多个客户端，只需监视多个对应的文件描述符即可，不需要新建进程。

**4.select函数的观察对象中应包含服务端套接字（监听套接字），那么应将其包含到哪一类监听对象集合？请说明原因。**

- 是否存在套接字接收数据
- 客户端连接请求本身也是从网络中接收到的一种数据，而接收客户端连接请求的任务是由服务器端套接字完成的

**5.select函数中使用的fd_set结构体在Windows和Linux中具有不同声明。请说明区别，同时解释存在区别的必然性。**

## 13章

**1.下列关于MSG_OOB可选项的说法错误的是？**
a.MSG_OOB指传输Out-of-band数据，是通过其他路径高速传输数据。

- TCP不另外提供单独的通信路径高速传输数据，只是利用TCP的紧急模式进行传输。

b.MSG_OOB指通过其他路径高速传输数据，因此，TCP中设置该选项的数据先到达对方主机。

- TCP不另外提供单独的通信路径高速传输数据，只利用TCP紧急模式进行传输。而且TCP“保持传输顺序”的传输特性依然成立。

c.设置MSG_OOB使数据先到达对方主机后，以普通数据的形式和顺序读取。也就是说，只是提高了传输速度，接收方无法识别这一点。

- 设置MSG_OOB后，使用TCP紧急模式进行传输数据，TCP保持传输顺序的传输特性依然成立。不会加快数据传输速度。紧急消息的意义在于督促消息处理，而非紧急传输形式受限的消息。

d.MSG\_OOB无法脱离TCP的默认数据传输方式。即使设置了MSG\_OOB，也会保持原有的传输顺序。该选项只用于要求接收方紧急处理。

- 正确，MSG_OOB可选项利用TCP的紧急模式进行传输数据，紧急消息的真正意义在于督促消息处理，而非紧急传输形式受限的消息。

**2.利用readv&writev函数收发数据有何优点？分别从调用次数和I/O缓冲的角度给出说明**

- 需要传输的数据分别位于不同缓冲（数组）时，如果调用write函数，就需要调用多次；如果使用writev，就可以通过1次writev函数调用将数据写入到输出缓冲。同样，需要将输入缓冲中的数据读入不同位置时，如果调用read函数就需要调用多次；而使用readv函数，则调用1次就可以满足要求。
- 假设为了提高效率而在服务器端明确阻止了Nagle算法，数据到达输出缓冲就发送。如果数据在多个不同的缓冲，如果此时使用write函数则需要调用多次。可能传递多个数据包。反之，若使用writev函数将所有数据一次性写入输出缓冲，则很有可能仅通过1个数据包传递数据。这样可以减少网络中数据包的个数。

**3.通过recv函数验证输入缓冲是否存在数据时（确认后立即返回时），如何设置recv函数最后一个参数中的可选项？分别说明各可选项的含义**

- MSG\_PEEK|MSG\_DONTWAIT
- MSG_PEEK：验证输入缓冲中是否存在接收的数据
- MSG_DONTWAIT：调用I/O函数时不阻塞，用于使用非阻塞(Non-blocking)I/O

**4.可在Linux平台通过注册事件处理函数接收MSG_OOB数据。那Windows中如何接收？请说明接收方法**



## 14章
### 1.TTL的含义是什么？请从路由器的角度说明较大的TTL值与较小的TTL值之间的区别及问题
- TTL是Time to Live的简写，是一个决定数据包传递距离的整数。在传递多播数据包的过程中，每经过1个路由器就减1.当TTL变为0时，该数据不无法再被传递，只能销毁。
- TTL的值设置过大将影响网络流量；设置过小会无法传递到目标

### 多播与广播的异同点是什么？请从数据通信的角度进行说明
- 多播和广播都可以一次性向多个主机发送数据
- 多播和广播传输数据的范围不同。多播即使在跨越不同网络的情况下，只要加入多播组就能接收数据。相反，广播只能向同一网络中的主机传输数据。

### 下列关于多播秒数错误的是？
#### a.多播是用来向加入多播组的所有主机传输数据的协议
正确
#### b.主机连接到同一网络才能加入多播组，也就是说，多播组无法跨越多个网络
错误，即使在跨越不同网络的情况下，只要加入多播组就能接收数据
#### c.能够加入多播组的主机数并无限制，但只能有1个主机（Sender）向该组发送数据
错误，加入特定组即可接收发往该多播组的数据，并无数量限制。只要设置好TTL和多播地址，任何主机都可以向改组发送数据。
#### d.多播时使用的套接字是UDP套接字，因为多播是基于UDP进行数据通信的
正确

### 多播也对网络流量有利，请比较TCP数据交换方式解释其原因
- 多播向网络传递1个多播数据包时，路由器将复制该数据包并传递到多个主机，因此，不会向同一区域（网络）发送多个相同的数据包。
- 若通过TCP向1000个主机发送文件，则共需要传递1000次，即便将1000台主机合为一个网络，使99%的传输路径相同的情况下也是如此。但此时若使用多播方式传输文件，则只需发送1次。这时由1000台主机构成的网络中的路由器负责复制文件并传递到主机。

### 多播方式的数据通信需要MBone虚拟网络。换言之，MBone是用于多播的网络，但它是虚拟网络。请解释此处的“虚拟网络”
- 通过网络中的特殊协议工作的软件概念上的网络。
- 也就是说，MBone并非可以触及的物理网络。它是以物理网络为基础，通过软件方法实现的多播通信必备虚拟网络。


## 15章
### 1.请说明标准I/O函数的2个优点。它为何拥有这2个优点？
- 标准I/O函数具有良好的移植性。所有的标准函数具有良好的移植性，这些函数都是按照ANSI C标准定义的。
- 标准I/O函数可以利用缓冲提高性能。使用标准I/O函数时会得到额外的缓冲支持。在传输数据时，使用缓冲可以减少传输的数据量，同时减少数据向输出缓冲移动的次数。

### 利用标准I/O函数传输数据时，下面的想法是错误的：
“调用fputs函数传输数据时，调用后应立即开始发送！”
为何说上述想法是错误的？为了达到这种效果应添加哪些处理过程？
- fputs是标准I/O函数，使用标准I/O函数传输数据时，会得到额外的缓冲支持。使用fputs传输数据时，首先将数据传递到标准I/O的缓冲，待缓冲满了后再将数据移动到套接字输出缓冲，最后将字符串发送到对方主机。
- 调用完fputs函数后，调用fflush函数，强迫将标准I/O函数缓冲区内的数据移动到套接字输出缓冲中，立即开始发送数据。


## 16章
### 1.下列关于FILE结构体指针和文件描述符的说法错误的是？
#### a. 与FILE结构体指针相同，文件描述符也分为输入描述符和输出描述符。
错误，文件描述符本身不会根据输入和输出进行区分。
#### b. 复制文件描述符时将生成相同值的描述符，可以通过这两个描述符进行I/O。
错误，复制文件描述符的含义是，为了访问同一文件或套接字，创建另一个文件描述符。值是不同的。
#### c. 可以利用创建套接字时返回的文件描述符进行I/O，也可以不通过文件描述符，直接通过FILE结构体指针完成。
错误，FILE结构体指针是基于文件描述符创建的。
#### d. 可以从文件描述符生成FILE结构体指针，而且可以利用这种FILE结构体指针进行套接字I/O。
正确，调用fdopen()基于文件描述符创建FILE结构体指针，调用标准函数fputs(),fgets()基于FILE结构体指针进行套接字I/O。
#### e.若文件描述符为读模式，则基于该描述符生成的FILE结构体指针同样是读模式；若文件描述符为写模式，则基于该描述符生成的FILE结构体指针同样是写模式。
错误，文件描述符不区分读模式和写模式。FILE结构体指针的模式由调用fdopen()时的参数决定。

### 2.EOF的发送相关描述错误的是？
#### a.中止文件描述符时发送EOF.
错误，若有多个文件描述符指向一个套接字，中止其中一个文件描述符不会发送EOF。
#### b.即使未完全中止文件描述符，关闭输出流时也会发送EOF.
正确
#### c.如果复制文件描述符，则包括复制文件描述符在内，所有文件描述符都中止时才会发送EOF.
正确
#### d.即使复制文件描述符，也可以通过调用shutdown函数进入半关闭状态并发送EOF。
正确


## 17章
### 1.利用select函数实现服务器端时，代码层面存在的2个缺点是？
- 调用select函数后常见的针对所有文件描述符的循环语句
- 每次调用select函数时都需要向该函数传递监视对象信息

### 2.无论是select方式还是epoll方式，都需要将监视对象文件描述符信息通过函数调用传递给操作系统。请解释传递该信息的原因。
监视文件描述符，就是监视套接字。而套接字是操作系统管理的资源，因此需要将文件描述符传递给操作系统。

### 3.select方式和epoll方式的最大差异在于监视对象文件描述符传递给操作系统的方式。说明具体的差异，并解释为何存在这种差异。
- select方式是在每次调用select函数时向操作系统传递监视对象信息；epoll方式是仅向操作系统传递1次监视对象，监视范围或内容发生变化时只通知发送变化的事项。
- select函数是通过观察作为监视对象的fd_set变量的变化，找出发生变化的文件描述符。每次调用完select函数后，作为监视对象的fd_set变量会发生变化，所以调用select函数前应复制并保存原有信息，并在每次调用select函数时传递新的监视对象信息；epoll方式下由操作系统负责保存监视对象的文件描述符，因此仅传递1次监视对象。

### 4.虽然epoll是select的改进方案，但select也有自己的优点。在何种情况下使用select方式更合理？
- 服务端接入者少
- 程序应具有兼容性

### 5.epoll以条件触发或边缘触发方式工作。二者有何区别？从输入缓冲的角度说明这2种方式通知事件的时间点差异。
条件触发和边缘触发的区别在于发生事件的时间点。条件触发方式中，只要输入缓冲有数据就会一直通知该事件；边缘触发中输入缓冲收到数据时仅注册1次该事件。即使输入缓冲中还留有数据，也不会再进行注册。

### 6.采用边缘触发时可以分离数据的接收和处理时间点。说明其原因及优点
- 边缘触发中输入缓冲收到数据时仅注册一次该事件。
- 即使输入缓冲收到数据（注册相应事件），服务器端也能决定读取和处理这些数据端时间点，这样就给服务端端的实现带来巨大的灵活性。 

